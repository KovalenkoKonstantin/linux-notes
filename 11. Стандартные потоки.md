### Философия Unix: Каналы и Потоки

В философии Unix один из принципов — это то, что программы должны быть простыми и выполнять одну задачу. Но для того, чтобы эти программы могли работать вместе, необходимо, чтобы они могли обмениваться данными.

#### Потоки в Unix

В Unix-подобных системах для обмена данными между программами используются **стандартные потоки**:
1. **stdin** — стандартный ввод (куда подаются данные, например, с клавиатуры).
2. **stdout** — стандартный вывод (куда выводятся данные, например, на экран).
3. **stderr** — стандартный вывод ошибок (сюда выводятся сообщения об ошибках).

Эти потоки помогают программам взаимодействовать и передавать данные без необходимости вмешательства пользователя.

---

### Направление Потоков

Для того чтобы программы могли передавать данные друг другу, используется **перенаправление потоков** и **каналы**.

1. **stdin** — знак для перенаправления стандартного ввода — это **`<`**. Например:
   ```bash
   mail user < file
   ```
   Здесь данные из файла перенаправляются как ввод в команду `mail`.

2. **stdout** — знак для перенаправления стандартного вывода — это **`>`**:
   ```bash
   ls > filelist
   ```
   Это перенаправит вывод команды `ls` в файл `filelist`. Если файл существует, он будет перезаписан.

   Если нужно добавить данные в конец файла, используется **`>>`**:
   ```bash
   grep user /etc/passwd >> filelist
   ```

3. **stderr** — знак для перенаправления вывода ошибок — это **`2>`**:
   ```bash
   grep -rl bash /etc 2> errors
   ```
   Ошибки будут записаны в файл `errors`, а нормальный вывод на экран.

4. Для того чтобы **"сжать" ошибки и нормальный вывод в одну команду**, можно использовать **`&>`**:
   ```bash
   grep -rl bash /etc &> output
   ```
   Это записывает и стандартный вывод, и ошибки в файл `output`.

---

### Каналы (Пайпы)

Для передачи данных от одной команды к другой используется **канал** (или **пайп**, символ **`|`**). Это позволяет передавать вывод одной программы как ввод для другой.

Примеры:
1. Чтобы получить только последние две строки из вывода команды `grep`:
   ```bash
   grep user /etc/passwd | tail -2
   ```
   Команда `grep` выводит результаты, а команда `tail -2` отбирает последние две строки.

   Аналогичную операцию можно было сделать с помощью временного файла - записать вывод команды `grep` в файл, а затем передать его в `tail`:
    ```bash
    grep user /etc/passwd > tempfile && tail -2 < tempfile
    ```
    Здесь:
    * `grep user /etc/passwd > tempfile` записывает вывод `grep` в файл `tempfile`.
    * Затем `tail -2 < tempfile` читает содержимое этого файла и выводит последние 2 строки.

!!! bash В общем случае, конвейер | — это наиболее удобный способ для передачи данных между командами.

2. Чтобы вывести 9-ю строку из файла `/etc/passwd`, можно использовать:
   ```bash
   head -9 /etc/passwd | tail -1
   ```
   Первая команда выводит первые 9 строк, а вторая — последнюю из этих 9 строк.

3. Если нужно вывести строки с 5 по 25 и найти слово "user", а потом сохранить результат в файл:
   ```bash
   tail -n +5 /etc/passwd | head -20 | grep games > file
   ```

---

### Пример: Как работает пайп (канал)

1. **Запрос данных с файла**:
   Мы хотим вывести все строки, начиная с 10-й, затем из них отобрать первые 30, а потом найти слово "unit" и результат записать в файл `unitfile`. Для этого:

   ```bash
   tail -n +10 /var/log/syslog | head -30 | grep unit > unitfile
   ```

2. **Запись и вывод одновременно**:
   Если нужно выводить данные на экран и одновременно записывать их в файл, используем команду **`tee`**:
   ```bash
   tail -n +5 /etc/passwd | head -20 | grep data | tee file
   ```
   Команда с `tee` перезаписывает файл, а если вы хотите добавить данные в файл, то используйте `tee -a` (опция `-a` означает `append` — добавление).
   ```bash
   tail -n +5 /etc/passwd | head -20 | grep data | tee -a file
   ```
   при этом данные уже существующие в файле на экран не будут введены:
![dicpic](/images/Untitled15.png)
---

### Заключение

С помощью **каналов (пайпов)** и **перенаправлений потоков** можно комбинировать различные команды и решать сложные задачи без необходимости создавать новые программы. Это позволяет эффективно работать с данными и управлять выводом ошибок, что является одним из принципов философии Unix.

### Вопросы:

1. **Перечислите стандартные потоки.**

   В Unix-подобных системах существуют три стандартных потока:
   - **stdin** — стандартный ввод (ввод данных в программу). `>`
   - **stdout** — стандартный вывод (вывод данных из программы). `<`
   - **stderr** — стандартный вывод ошибок (вывод ошибок из программы). `2>`

2. **Как и куда можно направлять стандартные потоки?**

   Стандартные потоки можно перенаправлять в:
   - **В файл**: Используя операторы **`>`** и **`>>`** для вывода данных в файл (перезапись и добавление соответственно).
   - **В другие программы**: Через **пайпы** (**`|`**), чтобы передать стандартный вывод одной команды как стандартный ввод другой.
   - **В "черную дыру"**: В `/dev/null`, чтобы просто игнорировать вывод.

3. **Как направить стандартный вывод в терминал и в файл одновременно?**

   Чтобы вывести данные и в терминал, и в файл, можно использовать команду **`tee`**:
   ```bash
   команда | tee имя_файла
   ```

   Если нужно добавить данные в файл, а не перезаписать его, используйте **`-a`**:
   ```bash
   команда | tee -a имя_файла
   ```

4. **Как направить stdout и stderr в один файл и в разные файлы?**

   - **В один файл** (stdout и stderr):
     ```bash
     команда &> файл
     ```
     или
     ```bash
     команда > файл 2>&1
     ```
   
   - **В разные файлы**:
     ```bash
     команда > stdout.txt 2> stderr.txt
     ```

---

### Задания:

1. **Запишите в файл `mykernel` последние 10 строк файла `/var/log/kdump.log`:**

   Для этого используем команду `tail` с перенаправлением вывода в файл:
   ```bash
   tail -n 10 /var/log/kdump.log > mykernel
   ```

2. **Добавьте (не перезаписывайте) в этот файл с 13 по 21 строки из файла `/etc/group`:**

   Для добавления данных в конец файла используем **`>>`**:
   ```bash
   head -n 21 /etc/group | tail -9 >> mykernel 
   ```
   ```bash
   sed -n '13,21p' /etc/group >> mykernel
   ```
   Команда `sed` — это сокращение от **"stream editor"** (потоковый редактор).

    `sed` используется для обработки и трансформации текстовых данных в потоке, позволяя выполнять различные операции, такие как поиск, замену, удаление или извлечение строк, а также для других текстовых манипуляций.
    Буква `p` в команде `sed` означает "print" (вывести). Когда вы используете `sed -n '13,21p',` она говорит `sed`, что нужно напечатать (вывести) строки с 13 по 21, которые попадают в указанный диапазон.

3. **Посмотрите файлы `mykernel` и `/etc/DDD`, при этом стандартный вывод направьте в файл `result.log`, а ошибки в файл `/tmp/ERRORS`:**

   Мы можем направить стандартный вывод и ошибки в разные файлы следующим образом:
   ```bash
   cat mykernel /etc/DDD > result.log 2> /tmp/ERRORS
   ```

4. **Направьте строки с 13 до 20 из файла `/etc/group` в файл `~/lines`, а потом добавьте в этот файл 16 строку из файла `/etc/passwd`:**

   Для первой части задачи:
   ```bash
   sed -n '13,20p' /etc/group > ~/lines
   ```
   `sed` - (**stream editor**)
   Для добавления 16-й строки из `/etc/passwd`:
   ```bash
   sed -n '16p' /etc/passwd >> ~/lines
   ```
    `sed` - (**stream editor**)

---

# 🛠 Tweak  

Чтобы вывести **только директории** из какого-либо каталога, можно использовать команду `ls` с параметром `-d` и с использованием фильтрации через `*/`, чтобы отобразить только директории.

```bash
ls -d /dev/*/
```

**Разбор:**

* `ls -d` — выводит информацию о директориях, а не о содержимом этих директорий.

* `/dev/*/` — фильтрует только директории (в Linux директории заканчиваются слэшем `/`).

Эта команда выведет все директории в каталоге `/dev`.

Чтобы вывести только **файлы**, исключив директории, можно использовать команду `find` с параметром `-type l`:

```bash
find /dev -maxdepth 1 -type l
```

### Разбор:
- **`find /dev`** — начинает поиск в каталоге `/dev`.
- **`-maxdepth 1`** — ограничивает поиск только текущим уровнем каталога (не будет заходить в подкаталоги).
- **`-type f`** — фильтрует только **файлы** (не включает директории).

Эта команда выведет все файлы в каталоге `/dev`, игнорируя директории.