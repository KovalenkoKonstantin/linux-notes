### Понимание переменных в bash

В `bash` переменные — это контейнеры для хранения значений, которые могут изменяться. Это один из важнейших элементов программирования, который используется для различных задач. Чтобы понять, как работают переменные в `bash`, давайте разобьем информацию на несколько шагов.

---

### Что такое переменные?

1. **Имя переменной** — это метка, которая указывает на некоторую информацию (значение).
2. **Значение переменной** — это информация, которая хранится в переменной и может меняться.

Пример:
- Имя переменной: `today`
- Значение переменной: `"28 апреля"` (или `"29 апреля"` завтра).

В `bash` переменные могут быть:
- **Локальными** (для текущей сессии или скрипта).
- **Переменными окружения** (для всего окружения, включая дочерние процессы).

---

### Локальные переменные (Shell variables)

Локальные переменные — это те переменные, которые существуют только в рамках текущей сессии терминала или скрипта.

**Пример:**

1. Создаем переменную и присваиваем ей значение:

```bash
files=file1
```

Здесь `files` — имя переменной, а `file1` — её значение.

2. Выводим значение переменной с помощью команды `echo`:

```bash
echo $files
```
Знак `$` в командной строке **Linux** (и в оболочке **Bash** в частности) используется для доступа к значению переменной.

**Обратите внимание:**
- Чтобы обратиться к значению переменной, используем `$`, как в `$files`.
- После этого, bash подставляет значение переменной в команду.

3. Используем переменную в других командах:

```bash
ls $files
rm -i $files
```

4. Удаление файла не повлияет на саму переменную. Если мы снова создадим файл с этим именем, переменная останется той же:

```bash
touch $files
```

---

### Важные правила для имен переменных

1. Имя переменной может содержать цифры, но не начинаться с них:
    - Правильно: `file1=file1`
    - Неправильно: `1file=file1`
  
2. Имя переменной не может содержать специальные символы (например, точку или дефис):
    - Неправильно: `file-1=file`
    - Неправильно: `file.1=file`

3. Имена переменных **регистрозависимы**:
    - `MyVar` и `myvar` — это две разные переменные.

4. Значение переменной может содержать пробелы, но тогда его нужно оборачивать в кавычки:

```bash
info="Some text here"
```

5. Переменные могут содержать значения других переменных:

```bash
files="file1 file2 file3"
myfiles="My files are $files"
echo $myfiles  # Выведет: "My files are file1 file2 file3"
```
Здесь `file1 file2 file3` — это просто текст.

Если мы не хотим, чтобы значение переменной интерпретировалось, а воспринималось как текст, можно использовать **одинарные кавычки** или **экранирование** символа `$`:

```bash
myfiles='My files are $files'  # Выведет: My files are $files
myfiles="My files are \$files"  # Выведет: My files are $files
```

---

### Переменные с командами

Иногда полезно присваивать переменным результаты выполнения команд. Для этого используем команду в **скобках** или **обратных кавычках**:

```bash
lines=$(tail -5 /etc/passwd | head -2)
echo $lines
```

Или старый способ с обратными кавычками:

```bash
lines=`tail -5 /etc/passwd | head -2`
```

---

### Как сохранить переменную для других сессий

Если вам нужно, чтобы переменная сохранялась после перезагрузки терминала или для новых сессий, можно добавить её в файл конфигурации оболочки:

- **Для локальных переменных**: добавьте строку с переменной в файл `~/.bashrc`:
  
```bash
files="file1 file2 file3"
```

Затем, при следующем запуске терминала, переменная будет доступна.

- **Для глобальных переменных** (которые должны быть доступны для всех пользователей): добавьте переменную в файл `/etc/profile` или `/etc/bashrc`.

---

### Переменные окружения (Environment variables)

Переменные окружения — это переменные, которые используются программами и процессами, чтобы передавать важную информацию о среде.

**Пример переменных окружения**:
- **`HOME`**: указывает на домашнюю директорию текущего пользователя.
- **`USER`**: указывает имя текущего пользователя.
- **`LANG`**: указывает язык, который будет использоваться в программах.
- **`PATH`**: указывает список директорий, где ищутся исполняемые файлы.

```bash
env | grep -E 'env | grep -E 'HOME|USER|LANG|PATH'
```
`-E` — включает расширенные регулярные выражения, что позволяет использовать символ `|` для логического `ИЛИ`.

Пример: изменим переменную окружения `LANG`, чтобы программы запускались на другом языке.

```bash
LANG=ru_RU.UTF-8
```

Теперь, например, Firefox запустится на русском языке, если это поддерживается.

Чтобы увидеть все переменные окружения, используем команду:

```bash
env
```
```bash
env | grep https_proxy
```

---

### Перевод локальной переменной в переменную окружения

Чтобы локальная переменная стала переменной окружения и передавалась в дочерние процессы, нужно использовать команду `export`.

**Пример:**

```bash
files=file1
export files
```

Теперь переменная `files` будет доступна не только в текущей сессии, но и в дочерних процессах.

---

### Разница между `~/.bashrc`, `~/.bash_profile` и `/etc/profile`

1. **`~/.bashrc`** — это файл, который используется для настройки **интерактивных оболочек** (терминалов). Он запускается при запуске терминала и используется для настройки переменных, алиасов и функций, которые будут работать в этой сессии.

2. **`~/.bash_profile`** — это файл, который используется для настройки **логин-сессий**. Этот файл обычно запускается при входе в систему (при логине).

3. **`/etc/profile`** и **`/etc/bashrc`** — это глобальные конфигурационные файлы, которые задают настройки для всех пользователей на системе.

Если вы хотите, чтобы переменная была доступна для всех пользователей, нужно добавить её в `/etc/profile` или `/etc/bashrc`.

---

### Заключение

Переменные в bash — это важный инструмент для хранения и работы с данными в командной строке. Они могут быть **локальными** или **переменными окружения**, и каждая из этих категорий имеет своё назначение. Вы можете использовать переменные для автоматизации задач, настроек и управления окружением.

### Вопросы

#### 1. Чем отличаются локальные переменные от переменных окружения?

- **Локальные переменные** (shell variables) существуют только в рамках текущей сессии оболочки (или скрипта) и не передаются в дочерние процессы. Они используются для выполнения операций внутри текущей оболочки или скрипта. Например, если вы создадите локальную переменную, она будет доступна только в текущей оболочке.

- **Переменные окружения** (environment variables) — это переменные, которые доступны всем дочерним процессам, запущенным из текущей оболочки. Эти переменные могут быть использованы программами и другими процессами, работающими в той же сессии.

Переменные окружения создаются с помощью команды `export`:

```bash
export MY_VAR="value"
```

Таким образом, переменные окружения передаются в дочерние процессы и сохраняются между сессиями, если они прописаны в конфигурационных файлах оболочки (например, `~/.bashrc`).

#### 2. Я задал переменную в `~/.bashrc` (например, `files=file1`), и она не является переменной окружения. Но при этом она работала в дочерних bash сессиях. Почему?

Переменные, заданные в `~/.bashrc`, являются **локальными переменными** для текущей оболочки (shell). Однако, если вы хотите, чтобы эта переменная стала переменной окружения и была доступна в дочерних процессах, вам нужно использовать команду `export`.

Но почему переменная всё же работает в дочерних bash-сессиях? Это связано с тем, что `~/.bashrc` выполняется при запуске **новой интерактивной оболочки**. Если вы открываете дочернюю оболочку (например, с помощью команды `bash`), то она будет использовать переменные, заданные в родительской оболочке, включая локальные переменные, которые уже были экспортированы.

---

### Задания

#### 1. Создайте переменную `curtime`, которая будет брать своё значение от команды `date`. Запишите переменную в `~/.bashrc`. Выведите значение переменной. Показывает ли она актуальное время и, если нет, почему?

**Решение:**

1. Откройте файл `~/.bashrc` для редактирования:

```bash
nano ~/.bashrc
```

2. Добавьте строку для создания переменной `curtime`, которая будет получать текущее время:

```bash
curtime=$(date)
```

3. Сохраните изменения и закройте файл.

4. Чтобы применить изменения, выполните:

```bash
source ~/.bashrc
```
**заново загружает и применяет настройки** из файла `~/.bashrc` в текущем терминале.

**Когда это нужно:**

* После изменения `~/.bashrc` (например, вы добавили новый алиас или переменную) — чтобы изменения применились без необходимости закрывать и заново открывать терминал.

5. Выведите значение переменной:

```bash
echo $curtime
```

**Почему переменная не показывает актуальное время?**
Переменная `curtime` будет содержать время, которое было получено на момент задания значения переменной, но не будет обновляться в будущем. То есть, если вы записали время в момент запуска оболочки, оно не будет изменяться в дальнейшем. Поэтому, если вы хотите, чтобы переменная показывала актуальное время при каждом вызове, вам нужно будет каждый раз обновлять её значение, например, с помощью команды `date` в момент вызова:

```bash
curtime=$(date)
echo $curtime
```

#### 2. Создайте переменную, значение которой показывает имя пользователя и имя системы, как в терминале — `user@alma9`.

**Решение:**

1. Откройте файл `~/.bashrc` для редактирования:

```bash
nano ~/.bashrc
```

2. Добавьте строку для создания переменной, которая будет содержать имя пользователя и имя системы:

```bash
user_system_info="${USER}@$(hostname)"
```

Здесь:
- `${USER}` — это системная переменная, которая хранит имя текущего пользователя.
- `$(hostname)` — это команда, которая возвращает имя текущей системы.

**скобки `{}` — это способ точно сказать:**

>"Заканчивай читать имя переменной вот здесь!"

**Почему нужны `()` в `$(hostname)`**
* `$(...)` — это **подстановка результата команды.**
* То есть Bash **выполнит команду внутри скобок** и подставит результат.

3. Сохраните изменения и закройте файл.

4. Чтобы применить изменения, выполните:
 **чтобы ручками перезагрузить** настройки прямо сейчас

```bash
source ~/.bashrc
```
`source` **— это общая идея "подгрузить скрипт в текущую сессию"**
Не только `~/.bashrc`, но и любой другой скрипт можно `source`-нуть.

5. Выведите значение переменной:

```bash
echo $user_system_info
```

Результат должен быть подобным:

```
user@alma9
```

Теперь эта переменная будет хранить имя текущего пользователя и имя системы, и будет доступна в новых сессиях.