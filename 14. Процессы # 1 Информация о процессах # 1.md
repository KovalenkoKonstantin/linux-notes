# 14. Процессы № 1 Информация о процессах № 1

---

# 14. Процессы № 1: Основы работы с процессами

## Как работает программа при запуске

Когда мы запускаем программу, она загружается в оперативную память.  
С накопителя (жёсткого диска или SSD) чтение происходит медленно, а процессор работает очень быстро — поэтому нужна оперативная память.

- Большие программы обычно загружаются в память частями — по мере необходимости.
- Каждой программе создаётся **виртуальная память**, чтобы она "думала", что работает одна.
- При запуске также загружаются:
  - Файлы настроек (например, `/etc/nanorc`, `~/.nanorc` для nano),
  - Библиотеки,
  - Открываемые файлы,
  - Переменные окружения.

**Когда программа работает в памяти, взаимодействует с процессором и диском, она становится процессом.**

---

## Потоки

Одна программа может выполнять несколько задач одновременно — например:
- Обрабатывать несколько клиентов на веб-сервере,
- Параллельно решать части сложного уравнения.

Для этого процесс создаёт **потоки**. Потоки:
- Делят одну виртуальную память,
- Но могут работать независимо.

Каждый процесс всегда имеет как минимум один поток.

---

## Просмотр процессов: команда `ps`

Администратору нужно уметь видеть процессы.  
Самая базовая команда:

```bash
ps
```

команда `ps` расшифровывается как **"process status".**

Она используется для отображения информации о запущенных процессах в системе.

Примеры:

`ps` — показывает процессы, запущенные в текущем терминале.

`ps aux` — показывает все процессы в системе в расширенном формате:

`a` — процессы всех пользователей,

`u` — выводит владельца процесса,

`x` — показывает процессы без управляющего терминала.

Она покажет процессы, запущенные в текущем терминале (например, `bash` и `ps`).

**Важно**: `ps` делает снимок процессов в момент запуска, поэтому он показывает даже сам себя.

---

### Ключи в `ps`

`ps` поддерживает разные типы ключей:

- Unix-стиль: один дефис (`-ef`)
- BSD-стиль: без дефиса (`aux`)
- GNU-стиль: два дефиса (`--sort`)

**Рекомендуемая комбинация** для просмотра всех процессов:

```bash
ps -ef
```
`-e` или `--everyone` — показывает все процессы в системе, а не только те, которые запущены в текущем сеансе.

`-f` или `--full` — включает подробную информацию о процессах.

Если нужно больше — читайте справку:

```bash
man ps
```

---

### Работа с длинным выводом

Вывод `ps -ef` часто не помещается на экран.  
Чтобы читать его удобно:

```bash
ps -ef | less -S
```

- `less -S` — отключает перенос строк, чтобы столбцы не "ломались".

---

## Разбор столбцов `ps -ef`

```bash
UID   PID  PPID  C  STIME  TTY          TIME  CMD
```

- **UID** — пользователь, от имени которого запущен процесс.
- **PID** — уникальный идентификатор процесса.
- **PPID** — идентификатор родительского процесса.
- **C** — процент использования процессора.
- **TTY** — терминал, связанный с процессом.
- **TIME** — сколько времени процессор потратил на процесс.
- **CMD** — команда, которой был запущен процесс.

---

### Подробнее о важных столбцах:

- **UID**  
  Большинство системных процессов запущены от `root`. Но для безопасности многие программы работают от отдельных "служебных" пользователей.

- **PID**  
  Уникальный номер процесса. После завершения процесса номер может быть использован снова.

- **PPID**  
  Почти каждый процесс запущен другим процессом. Пример:
  - `nano` → запущен из `bash`,
  - `bash` → запущен из графического окружения,
  - всё в итоге восходит к `systemd` — первому процессу.

- **C**  
  Загруженность процессора. У большинства процессов — 0%.

- **TTY**  
  Какой терминал связан с процессом:
  - `tty1`, `tty2` — виртуальные терминалы (Ctrl+Alt+F1-F2),
  - `pts/0`, `pts/1` — эмуляторы терминала в графической среде.

- **TIME**  
  Общее время работы процессора на процесс.

- **CMD**  
  Какую команду запустили для создания процесса. Если имя в квадратных скобках, значит это процесс ядра.

---

## Наблюдение за процессами в реальном времени

Команда:

```bash
watch "ps -ef | grep firefox"
```

позволяет наблюдать за процессом в реальном времени (обновление каждые 2 секунды).

---

## Где хранится информация о процессах

В Linux процессы представлены как файлы.  
Чтобы не нагружать диск, используется **виртуальная файловая система** — `procfs`, примонтированная в `/proc`.

```bash
cd /proc
ls
```

- Каталоги с номерами — это PID процессов.
- Содержимое `/proc` создаётся ядром **на лету**.

---

### Примеры файлов в `/proc`:

- `version` — версия ядра:

  ```bash
  cat /proc/version
  ```

- `uptime` — время работы системы (первое число — общее время, второе — время, сколько система была "праздной"):

  ```bash
  cat /proc/uptime
  ```

- В каталоге процесса `/proc/<PID>/`:
  - `cmdline` — команда запуска,
  - `environ` — переменные окружения,
  - `status` — статус процесса.

Пример:

```bash
ps -ef | grep firefox
cd /proc/<PID>
cat cmdline
cat environ
cat status
```

---

# Практика


### 1. **Запустите `ps -ef | head` и объясните значение каждого столбика.**

Когда ты выполняешь команду `ps -ef | head`, она выводит список процессов, но только первые 10 строк (по умолчанию команда `head` выводит 10 строк).

**Пример вывода:**

```bash
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 11:33 ?        00:00:00 /usr/lib/systemd/systemd --switched-root --system --deserialize 31 rhgb
root           2       0  0 11:33 ?        00:00:00 [kthreadd]
root           3       2  0 11:33 ?        00:00:00 [pool_workqueue_]
root           4       2  0 11:33 ?        00:00:00 [kworker/R-rcu_g]
root           5       2  0 11:33 ?        00:00:00 [kworker/R-rcu_p]
root           6       2  0 11:33 ?        00:00:00 [kworker/R-slub_]
root           7       2  0 11:33 ?        00:00:00 [kworker/R-netns]
root           9       2  0 11:33 ?        00:00:00 [kworker/0:0H-events_highpri]
root          10       2  0 11:33 ?        00:00:00 [kworker/u4:0-events_unbound]
```

### Объяснение столбцов:

1. **`UID`** — Идентификатор пользователя, который запустил процесс. Например, `root` или `user`.
2. **`PID`** — Идентификатор процесса (Process ID). Это уникальный номер процесса.
3. **`PPID`** — Идентификатор родительского процесса (Parent Process ID). Это процесс, который запустил текущий процесс.
4. **`C`** — Используемый процессором процент времени, которое данный процесс использует на CPU.
5. **`STIME`** — Время запуска процесса. Например, "Apr24" означает, что процесс был запущен 24 апреля.
6. **`TTY`** — Терминал, в котором был запущен процесс (например, `pts/0`, `tty1`).
7. **`TIME`** — Общее количество времени процессорного времени, которое данный процесс использует.
8. **`CMD`** — Команда, которая запустила процесс. Например, `/sbin/init` или `bash`.

---

### 2. **Выведите список процессов вашего пользователя.**

Чтобы вывести процессы только вашего пользователя, можно использовать команду `ps` с фильтром по имени пользователя:

```bash
ps -u user
```

### 3. **Выведите список процессов, запущенных в эмуляторах терминала.**

Чтобы найти процессы, запущенные в эмуляторах терминала, можно использовать `ps` с фильтрацией по терминалу (`TTY`):

```bash
ps -ef | grep tty
```

Это выведет все процессы, запущенные в эмуляторах терминала (например, `tty1`).

### 4. **Запустите `gedit`, найдите его `pid`, найдите `pid` его родительского процесса и так по цепочке все родительские `pid`-ы.**

1. Сначала запустите **`gedit`**:
   ```bash
   gedit
   ```

2. После этого найдите его **`PID`** с помощью команды `ps`:
   ```bash
   ps -ef | grep gedit
   ```

   Это должно вернуть что-то вроде:

   ```bash
   user       10639    2479  0 16:07 pts/0    00:00:00 grep --color=auto gedit
   ```

   Где **`10639`** — это **`PID`** `gedit`.

3. Теперь найдите **`PPID`** (родительский процесс) для `gedit`:
   ```bash
   ps -ef | grep 2479
   ```

   Где **`2479`** — это **`PPID`** (родительский процесс `gedit`).

   Это даст вам следующий процесс в цепочке родительских процессов.

4. Повторяйте эти шаги, пока не дойдете до процесса с **`PPID` = 1** (что обычно означает процесс, управляемый ядром системы, например, `init`).

